<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://vforvoid.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="http://vforvoid.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2023-03-29T06:56:20+00:00</updated><id>http://vforvoid.github.io//feed.xml</id><title type="html">blank</title><subtitle>Graphomaniac&apos;s blog about development </subtitle><entry><title type="html">Walking down the memory lane</title><link href="http://vforvoid.github.io//blog/2023/walking-down-the-memory-lane/" rel="alternate" type="text/html" title="Walking down the memory lane"/><published>2023-03-28T13:25:00+00:00</published><updated>2023-03-28T13:25:00+00:00</updated><id>http://vforvoid.github.io//blog/2023/walking-down-the-memory-lane</id><content type="html" xml:base="http://vforvoid.github.io//blog/2023/walking-down-the-memory-lane/"><![CDATA[<p>I spent my teenage years in a rather poor, depressive ‚Äúbedroom community‚Äù neighborhood of a post-Soviet-collapse industrial city. I would have likely ended up working in a semi-bankrupt factory and spending my evenings on the sofa drinking beer in front of the TV. However, my father surprised me on my twelfth birthday (it was 2012) with an old ZX Spectrum 48K, which turned out to be the best gift I ever received.</p> <p><img src="/assets/img/walking-down-the-memory-lane/zx.png" width="100%" alt="Image of the old ZX Spectrum 48K computer that. Black keyboard mono-block computer. Rainbow diagonal strip in the bottom right corner. Each key has a bunch of commands written on top of them." title="ZX Spectrum 48K, mine was some export version of it and was white though"/></p> <p>It was a machine that was released in 1982. It didn‚Äôt have any operating system at all, nor did it have a hard drive. All this computer had was a BASIC interpreter burnt into its read-only memory circuit and a very rudimentary code editor. You could use your TV as its screen, just like with a PlayStation. I also received a cassette tape with a dozen games and apps on it as a bonus. Yes, before floppy disks got popular, you were supposed to connect an audio tape player to the computer, rewind your cassette to the correct spot, type a command, and press play to start loading the data you wanted from persistent memory. Then, you had to wait for five minutes, enjoying the <a href="https://www.youtube.com/watch?v=1Y9V0yfO1T0">beeping sounds</a> that are very similar to those made by dial-up modems. 95% of the time, the app loaded successfully. Other 5% of the time, you had to rewind the tape and start over. I had a portable audiotape player, but it had a 3.5mm jack for headphones, while the computer had a <a href="https://en.wikipedia.org/wiki/DIN_connector">5-pin DIN</a> audio outlet. So, to load the first games from the tape onto this beast, I had to make my first adapter by cutting and soldering two wires together.</p> <p>When I first set up the computer, I wanted to start loading and playing the games, but I didn‚Äôt know how to enter the command that would make the computer wait for the input data from the tape. Obviously, none of my relatives or friends knew how to use this relic of the machine either, so I was on my own. Fortunately, I found an old softcover book with a BASIC manual printed on cheap yellow paper which was included with the PC. I spent a few minutes looking for the ‚Äúlaunching games‚Äù chapter, but it was not there. Disappointing, but totally expected. However, I thought to myself, ‚ÄúIf there are games on the tape, there must be a way to load them, right? There‚Äôs no way this book doesn‚Äôt have this information. I gotta read it.‚Äù</p> <p>I began reading the first few chapters which covered variables, math operations, and printing out text. I experimented with basic math and variables and thought to myself, ‚ÄúWhoa! I can use this thing as a powerful calculator for my math homework!‚Äù I pressed on and read about conditions, cycles, and drawing shapes on the screen and went experimenting with this new knowledge. I became completely absorbed. I spent an entire day writing programs that drew bizarre ornaments made of lines and circles. ‚ÄúDraw circles in a for loop with the common center with the given step in a radius. That‚Äôs a bullseye! Draw 1000 circles in random coords with random radii. Oh cool, it kinda looks like ripples from the raindrops.‚Äù It was extra fascinating because drawing was noticeably slow on this machine: you could observe how computer is drawing lines pixel by pixel, so there was an impression that somebody methodically makes strokes with a brush. The next day, I eagerly read a chapter on sound output and using the built-in beeper. I discovered that I could give it a pitch and duration, and it would play sounds for me. I was learning to play a guitar around same time and I knew the basics of music theory, so I spent the entire day writing small tunes on this piece of plastic.</p> <p>And then I discovered the ‚ÄúUser Input‚Äù chapter and started creating basic games. I believe the first game I ever made had about 20 lines of code. You press the space button, and it starts a random timer where ‚Äúyou act normal as if nothing is happening, living your usual life.‚Äù A few seconds later, it makes a beeping signal that notifies you that the giant volcano in the center of your room is about to erupt. It then starts a random duration ‚Äúvolcano eruption timer‚Äù that lasts for about 3 to 10 seconds. During that time period, you are supposed to pick up as many toys from the floor as you can and jump onto the bed. When the volcano timer runs out, the computer emits a long, nasty, high-pitched beep that means the floor has just turned into hot lava. If you get caught staying on the floor, you‚Äôre dead, gg wp. Otherwise, you get an amount of points equal to the number of toys you were able to ‚Äúsave from lava‚Äù. The collected toys are then thrown back on the ground, and a new round begins. Whoever gets more points in multiple rounds wins. How is this not an AR game üòÑ? Obviously, I wrote more complex and ‚Äútraditional‚Äù video games later, but this one has a special place in my heart.</p> <p><img src="/assets/img/walking-down-the-memory-lane/volcano-room.png" width="100%" alt="Midjourney AI generated image. Prompt: Create a vibrant fable-inspired cartoon image depicting a cozy children's bedroom with two ten-year-old boys. The bed is situated towards the back of the room, and a shelf is to the left. In the center of the room, there is a 40-centimeter-tall volcano that is erupting, spewing lava that has already started to cover parts of the floor. The boys are in mid-air, jumping onto the bed while holding onto their favorite toys, which they are rescuing from the lava. Toys litter the ground of the room, and one of them has even caught fire from the heat. The boys' faces are filled with joy and laughter, as the volcanic eruption is all part of their imaginary game." title="The way we imagined it as a kids."/></p> <p>And yes, I found out how to load and save programs to and from the tape. I even played a few <a href="https://youtu.be/lHAPELM3eCc?t=11">retro ZX games</a>, so I kinda got what I came for. But by this point, my brain had already been irreversibly damaged by programming. Playing games no longer held the same appeal for me. I was fascinated by the idea that I could control what the machine did: I simply gave it a list of instructions, and it obeyed them. It was absolutely mind-blowing and magical for me. It was infinitely cooler than my rich classmate‚Äôs remote-controlled car. I had a golem of plastic and silicon in my room that could process data and display it on the screen according to my instructions. I didn‚Äôt have to be in front of it all the time; I could automate the machine‚Äôs responses to various inputs and save the program for later use. It‚Äôs a mundane thing for me and everyone else now, but at that moment, it felt too good to be true.</p> <p>And that‚Äôs how I got into programming.</p>]]></content><author><name></name></author><category term="programming"/><category term="programming"/><summary type="html"><![CDATA[How and why I started programming]]></summary></entry><entry><title type="html">Programming language soup</title><link href="http://vforvoid.github.io//blog/2023/language-soup/" rel="alternate" type="text/html" title="Programming language soup"/><published>2023-03-05T17:00:00+00:00</published><updated>2023-03-05T17:00:00+00:00</updated><id>http://vforvoid.github.io//blog/2023/language-soup</id><content type="html" xml:base="http://vforvoid.github.io//blog/2023/language-soup/"><![CDATA[<p>It may not sound like the best idea to learn and use several programming languages at the same time, especially from a career standpoint. It‚Äôs generally better to focus on one or a few similar languages and learn them in-depth. However, as someone who is passionate about programming, I don‚Äôt care as much. I believe that learning multiple languages, even just a little, can have its own perks. It can help you become aware of different approaches and concepts that you can employ to solve various problems.</p> <p>I have seen on multiple occasions how people who only work within a single language and ecosystem can become trapped in a particular way of thinking. In fact, this is a very natural process similar to how our brains work with natural languages: If you spend too much time thinking in a particular language, it will inevitably carve neural highways in your brain that make it difficult for you to think outside of the framework this language provides. Language creates the doors of perception for its user, not a breaking news.</p> <p>You might hear people say things like ‚ÄúX is unidiomatic in my language,‚Äù ‚ÄúX is discouraged in my language,‚Äù ‚Äúnobody does X this way in my language,‚Äù ‚ÄúX feels weird in my language,‚Äù or ‚ÄúX does not perform well in my language.‚Äù While all of these statements may be true in one language or ecosystem, they might not be the case in other ones. It‚Äôs hard to see these differences until you experience working in a different language yourself. By doing so, you can gain a better understanding of the strengths and weaknesses of each language and how to use them effectively. You can borrow ideas that you like from the other languages and use them in your primary one.</p> <p>I strongly encourage anyone who is passionate about programming to learn at least the basics of a language that is <strong>significantly</strong> different from what they already know and use every day. For example, if you‚Äôre very familiar with Java, don‚Äôt just learn Kotlin (well, ok, probably <em>do</em> learn Kotlin anyway). Learn Python or Elm instead, which will challenge you to think differently and will probably be a paradigm shift for you. Similarly, if you do a lot of JavaScript, don‚Äôt go for Python, learn Haskell or Rust, otherwise you risk not to learn anything that is significantly new. Taking a leap of faith and stepping out of your comfort zone and trying something new can be incredibly fascinating and useful!</p> <p>Ok, enough of the foreword. Here‚Äôs a list of programming languages I‚Äôve worked with throughout my life, roughly in the order they were introduced to me:</p> <ol> <li><a href="#basic">Basic</a></li> <li><a href="#pascal">Pascal</a></li> <li><a href="#delphi">Delphi</a></li> <li><a href="#c">C</a></li> <li><a href="#cpp">C++</a></li> <li><a href="#c-sharp">C#</a></li> <li><a href="#php">PHP</a></li> <li><a href="#java">Java</a></li> <li><a href="#asm">Assembly</a></li> <li><a href="#javascript">JavaScript</a></li> <li><a href="#python">Python</a></li> <li><a href="#r">R</a></li> <li><a href="#scala">Scala</a></li> <li><a href="#lisp">Lisp (Scheme)</a></li> <li><a href="#kotlin">Kotlin</a></li> <li><a href="#elm">Elm</a></li> <li><a href="#typescript">TypeScript</a></li> <li><a href="#rust">Rust</a></li> </ol> <p>Note that:</p> <ul> <li>‚ÄúExperience‚Äù reflects my subjective perception of how experienced I am with a particular language in comparison to other languages I‚Äôve used, not how experienced and proficient I am in comparison to some other developer or you.</li> <li>The pros and cons I mention are based on the state of the language around the time I was using it and might not be true anymore. I wouldn‚Äôt even pretend pros and const lists are comprehensive either. I could also easily miss some obvious solution for the downside of the language, as I‚Äôm just a human.</li> <li>For the sake of brevity, I won‚Äôt include things like: <ul> <li>Data markup languages and formats like HTML, XML, JSON, etc</li> <li>Query languages like SQL, GraphQL, GraphDB, mongo, elastic search queries</li> <li>Style sheet languages like CSS, SCSS, Less</li> <li>Different flavors of regular expression languages</li> </ul> </li> </ul> <hr/> <h2 id="basic">Basic</h2> <dl> <dt>Used it in prod?</dt> <dd>‚ùå No</dd> <dt>Experience</dt> <dd>‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</dd> <dt>Enjoyment</dt> <dd>‚ù§Ô∏è‚ù§Ô∏èüñ§üñ§üñ§</dd> <dt>Comments</dt> <dd>Mostly used it before I turned sixteen. I wrote a lot of small games for myself and my cousin on an <a href="/blog/2023/walking-down-the-memory-lane/">old, dusty ZX machine</a>. Tetris and Sokoban was the most complex out of them. Also automated certain very repetitive parts of my math-y homework.</dd> <dd><strong>Pros</strong>: Very easy to pick up as a kid.</dd> <dd><strong>Cons</strong>: Basic is way too basic. The dialect I used was particularly limited, with only support for one big flat file, and manual line numbering required. Additionally, there was barely any function support (GOSUB) and pervasive use of GOTO.</dd> </dl> <hr/> <h2 id="pascal">Pascal</h2> <dl> <dt>Used it in prod?</dt> <dd>‚ùå No</dd> <dt>Experience</dt> <dd>‚≠ê‚≠êüåëüåëüåë</dd> <dt>Enjoyment</dt> <dd>‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏èüñ§üñ§</dd> <dt>Comments</dt> <dd>Learnt it in a high school, along with other basics like ADTs and high-level compiler theory.</dd> <dd><strong>Pros</strong>: Decent language to learn about strict type system. Has a nice functions support.</dd> <dd><strong>Cons</strong>: I don‚Äôt think I can recall any cons for the language itself really. It‚Äôs just the fact that it was out of use in production already when I learnt it.</dd> </dl> <hr/> <h2 id="delphi">Delphi</h2> <dl> <dt>Used it in prod?</dt> <dd>‚ùå No</dd> <dt>Experience</dt> <dd>‚≠êüåëüåëüåëüåë</dd> <dt>Comments</dt> <dd>Coded my first basic Windows GUI apps in it. It was a cool and refreshing experience to use a visual WYSIWYG UI editor for the first time in my life. However, I soon realized that C# was a better option for this purpose, as it was backed by Microsoft and had more support for modern programming practices.</dd> </dl> <hr/> <h2 id="c">C</h2> <dl> <dt>Used it in prod?</dt> <dd>‚úÖ Yes</dd> <dt>Experience</dt> <dd>‚≠ê‚≠êüåëüåëüåë</dd> <dt>Enjoyment</dt> <dd>‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏èüñ§üñ§</dd> <dt>Comments</dt> <dd>Occasionally used it when I needed a performance boost. Or didn‚Äôt have other choice, such as when I needed to create bindings for a library that was written in C. 10/10, would segfault again. I appreciate the power and low-level control that C gives the programmer.</dd> </dl> <hr/> <div id="cpp"></div> <h2 id="c-1">C++</h2> <dl> <dt>Used it in prod?</dt> <dd>‚úÖ Yes</dd> <dt>Experience</dt> <dd>‚≠ê‚≠ê‚≠êüåëüåë</dd> <dt>Enjoyment</dt> <dd>‚ù§Ô∏è‚ù§Ô∏èüñ§üñ§üñ§</dd> <dt>Comments</dt> <dd>Worked with it quite a lot with OpenCV and Boost a while ago. Also did some desktop client development with WinAPI and QT. I mostly wrote pure-C-style though, avoiding objects as much as possible, and I haven‚Äôt followed C++ news/standards.</dd> </dl> <hr/> <div id="c-sharp"></div> <h2 id="c-2">C#</h2> <dl> <dt>Used it in prod?</dt> <dd>‚úÖ Yes</dd> <dt>Experience</dt> <dd>‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</dd> <dt>Enjoyment</dt> <dd>‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏èüñ§</dd> <dt>Comments</dt> <dd>Picked it up while studying in university. Between 2013 and 2016, I did a lot of backend and Windows desktop client development using C#. I utilized it with various technologies such as WinForms, WPF, WCF, Entity Framework, ASP.NET, and SimpleInjector. I thought I‚Äôm going to specialize in C#, but I became increasingly concerned about the future of both Microsoft and myself. .NET Core was not really a thing back then and MS was not <strong>that</strong> involved in the opensource as it is now. This pushed me into exploring other languages as I was looking for the plan B for my career.</dd> <dd><strong>Pros</strong>: Absolutely awesome <a href="https://stackoverflow.com/a/4683716/2782477">Haskell-inspired</a> lazy collection processing semantics (LINQ) for an OOP language. Decent FFI. Good multithreading and task API. C# also got async/await very early. Nice reflection with non-erasable generics. Extension methods.</dd> <dd><strong>Cons</strong>: Dependence on the runtime, lack of cross-platform support and inability to compile to native (at least back then). Lack of proper <a href="https://www.youtube.com/watch?v=O89-zG84QK4">immutability</a>, or at least one had to try very hard to achieve it. EntityFramework gave me a slight ORM-phobia, because it makes it very easy for developer to write things that has terrible performance. Working with pure data is a bit awkward (anonymous objects make it a bit easier though). Dependence on Visual Studio projects and its build tools. Uncertain future of Microsoft (back then).</dd> </dl> <hr/> <h2 id="php">PHP</h2> <dl> <dt>Used it in prod?</dt> <dd>‚ùå No, thanks</dd> <dt>Experience</dt> <dd>üåëüåëüåëüåëüåë</dd> <dt>Enjoyment</dt> <dd>üñ§Ô∏èüñ§üñ§üñ§üñ§</dd> <dt>Comments</dt> <dd>In 2009, I was introduced to web development using this language. Unfortunately, it gave me a deep disgust for anything related to web development for years. I can‚Äôt say for sure if it has improved since then, but even after all these years, I still have no desire to revisit it.</dd> </dl> <hr/> <h2 id="java">Java</h2> <dl> <dt>Used it in prod?</dt> <dd>‚úÖ Yes</dd> <dt>Experience</dt> <dd>‚≠ê‚≠ê‚≠êüåëüåë</dd> <dt>Enjoyment</dt> <dd>‚ù§Ô∏è‚ù§Ô∏èüñ§üñ§üñ§</dd> <dt>Comments</dt> <dd>Used it with ANTLR and CoreNLP on a backend mostly. It was before Java 8 and there were no stream API. I always thought of Java as an older, more conservative brother of C#, who works in a big enterprise company with broader reach.</dd> <dd><strong>Pros</strong>: Awesome ecosystem, decent tooling, and great deal of language stability. You still do need a runtime, but it‚Äôs more ubiquitous than .NET and more cross-platform.</dd> <dd><strong>Cons</strong>: The main issue I had with Java is its verbosity and amount of ceremony one needs to accomplish even the most basic tasks. This was compounded by the absence of the stream API back then, and I was already spoiled by C#‚Äôs LINQ, so it further degraded my experience.</dd> </dl> <hr/> <div id="asm"></div> <h2 id="assembly-language-turbo-assembler-specifically">Assembly language, Turbo Assembler specifically</h2> <dl> <dt>Used it in prod?</dt> <dd>‚ùå No</dd> <dt>Experience</dt> <dd>üåëüåëüåëüåëüåë</dd> <dt>Enjoyment</dt> <dd>‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏èüñ§üñ§</dd> <dt>Comments</dt> <dd>Although I‚Äôve only used it for university course assignments, I found it surprisingly enjoyable to work with. Despite the tedium of controlling the machine on such a low level, there was something weirdly satisfying about having complete control over almost every aspect of the program‚Äôs execution. While I wouldn‚Äôt want to spend my entire career writing Assembly code, it‚Äôs definitely a language worth learning for those interested in understanding computers guts.</dd> </dl> <hr/> <h2 id="javascript">JavaScript</h2> <dl> <dt>Used it in prod?</dt> <dd>‚úÖ Yes</dd> <dt>Experience</dt> <dd>‚≠ê‚≠ê‚≠êüåëüåë</dd> <dt>Enjoyment</dt> <dd>‚ù§Ô∏è‚ù§Ô∏èüñ§üñ§üñ§</dd> <dt>Comments</dt> <dd>JavaScript has long been the ‚Äúvendor lock‚Äù for browsers, with only recently the introduction of the WASM being its closest, immature competitor. I first started using JavaScript in production in 2016 to build simple front-ends with the help of packages like Bootstrap, React, and Angular. More recently, in 2019, I also used it on the backend for a data ingestion pipeline. While JavaScript is frustrating at times, especially with its endless quirks and inconsistencies, its ubiquity and versatility make it an essential tool in any web developer‚Äôs toolkit. No matter if you like it or not, it‚Äôs the <a href="https://survey.stackoverflow.co/2022/#most-popular-technologies-language">most popular language</a> right now and often used as a lingua franca in the programming community.</dd> <dd><strong>Pros</strong>: Surprisingly ubiquitous and very accessible. Popularized JSON. Ceremony-free way to declare and manipulate dictionary-like data records (‚Äúobjects‚Äù). Nice arrow style for functions. You barely need any tools to start working with it, just open your browser.</dd> <dd><strong>Cons</strong>: But if you want to work with it more than few days, boy oh boy, you will need to learn about all the tools in the observable universe and then some. And these tools will surely change every few months. NPM is the language‚Äôs biggest blessing and curse. <code class="language-plaintext highlighter-rouge">is-even</code> and <code class="language-plaintext highlighter-rouge">left-pad</code> became proper nouns. Language designed in 10 days, prank got out of control, and now it‚Äôs design by committee. Absolutely rudimentary core lib which gives you a <code class="language-plaintext highlighter-rouge">Set</code> class without methods to intersect or union sets out of the box. 2GB of <code class="language-plaintext highlighter-rouge">node_modules</code> in a barebone autogenerated project template. JS folks are generally lenient towards taking on extra dependencies for their projects. Multithreading is hard. Coerces everything to a string. <code class="language-plaintext highlighter-rouge">this</code> acts differently depending on a context. I can go on and on and on.</dd> </dl> <hr/> <h2 id="python">Python</h2> <dl> <dt>Used it in prod?</dt> <dd>‚úÖ Yes</dd> <dt>Experience</dt> <dd>‚≠ê‚≠ê‚≠ê‚≠êüåë</dd> <dt>Enjoyment</dt> <dd>‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏èüñ§</dd> <dt>Comments</dt> <dd>In 2019, I utilized Python to build a data ingestion pipeline on the backend and created simple back- and frontends using Django and Django REST. Currently, I‚Äôm actively utilizing Python for machine learning projects with things like scikit, TensorFlow, Torch, and few gradient boosting packages to train, fine-tune and deploy language models to AWS SageMaker. Python is undeniably good choice for ML tasks and an excellent language for small projects and scripts. It‚Äôs very easy to get something running with it really fast.</dd> <dd><strong>Pros</strong>: The best ecosystem for ML. A lot of the packages are written in ‚Äúfaster system languages‚Äù which gives the whole ecosystem extra edge in performance department. Nice list / dict / iterable comprehension syntax. Ability to manipulate pure data structures like dictionaries without necessity to create a class for every possible structure.</dd> <dd><strong>Cons</strong>: <code class="language-plaintext highlighter-rouge">pip</code> package manager is somewhat unergonomic, but this can be solved by using something like <code class="language-plaintext highlighter-rouge">poetry</code>. I still get into trouble importing code from the local packages sometimes. Certain ML-related workloads require creating a little dependency hell on your machine. Multithreading is rather hard, thanks to GIL. It‚Äôs necessary to use <code class="language-plaintext highlighter-rouge">venv</code> to isolate dependencies of projects. Lambda syntax is cumbersome. Async/await was added rather late. Type annotations is a great effort, but it‚Äôs very late to the party.</dd> </dl> <hr/> <h2 id="r">R</h2> <dl> <dt>Used it in prod?</dt> <dd>‚úÖ Yes, barely</dd> <dt>Experience</dt> <dd>‚≠êüåëüåëüåëüåë</dd> <dt>Enjoyment</dt> <dd>‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏èüñ§</dd> <dt>Comments</dt> <dd>I used it around 2015 with <a href="https://www.shinyapps.io">Shiny</a> to visualize energy consumption statistical predictive model‚Äôs work. I didn‚Äôt spend a lot of time with it, but I found the experience to be quite pleasant. It was my first foray into building a truly reactive web UI, and I must say, it felt much purer than the ‚Äúpure components‚Äù of React.</dd> </dl> <hr/> <h2 id="scala">Scala</h2> <dl> <dt>Used it in prod?</dt> <dd>‚úÖ Yes, barely</dd> <dt>Experience</dt> <dd>‚≠êüåëüåëüåëüåë</dd> <dt>Comments</dt> <dd>In 2017, I had the opportunity to use Scala to create an Akka Rest API wrapper around an information extraction library. While I didn‚Äôt form a concrete opinion on it, I did notice that it still had the Java-like verbosity that I found somewhat cumbersome. It also seems like it tries to be both good at OOP and FP at the same time, with its costs and benefits. Dotty (aka Scala 3) looks interesting as well, but I‚Äôm afraid Java-centric community will be repulsed by the language instability.</dd> </dl> <hr/> <div id="lisp"></div> <h2 id="lisp-scheme">Lisp (Scheme)</h2> <dl> <dt>Used it in prod?</dt> <dd>‚ùå No</dd> <dt>Experience</dt> <dd>üåëüåëüåëüåëüåë</dd> <dt>Enjoyment</dt> <dd>‚ù§Ô∏è‚ù§Ô∏èÔ∏è‚ù§Ô∏è‚ù§Ô∏èüñ§</dd> <dt>Comments</dt> <dd>That‚Äôs pretty much an honorable mention here. I learnt it while going through <a href="https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs">SICP</a>. Very fun and extremely minimalistic language. Certainly a good gymnastics for one‚Äôs brain. After watching a fair amount of <a href="https://www.youtube.com/watch?v=kGlVcSMgtV4">Rich Hickey‚Äôs lectures</a> I wanted to try out Clojure, but unfortunately I haven‚Äôt yet.</dd> </dl> <hr/> <h2 id="kotlin">Kotlin</h2> <dl> <dt>Used it in prod?</dt> <dd>‚úÖ Yes</dd> <dt>Experience</dt> <dd>‚≠ê‚≠êüåëüåëüåë</dd> <dt>Enjoyment</dt> <dd>‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏èüñ§</dd> <dt>Comments</dt> <dd>I got to work with Kotlin in 2020 when I was developing a pet project of mine. And then I commercially made a simple kiosk-mode Android application with it. While I didn‚Äôt enjoy working on the Android app part, I was pleasantly surprised by the language itself. It felt much better than C# and Java, and I think it will make a decent ‚ÄúJava++‚Äù. It has taken many of the things I loved about C#.</dd> <dd><strong>Pros</strong>: Functions are finally feel like first-class citizens in an otherwise OOP language, you no longer have to stuff them into static classes. Another notable experimental feature is the ability to compile to native code. Kotlin also has explicit nullability, ensuring that null values are handled appropriately. The language has good 2-way interoperability with Java, allowing developers to use existing Java code. Composition over inheritance is baked into the language in the form of delegation. Kotlin‚Äôs core library has excellent collection processing capabilities. Suspended functions are also available, allowing for asynchronous programming. Additionally, Kotlin‚Äôs convention of specifying the last lambda outside of parameter parentheses is a neat feature. And the most important feature: no need for semicolons.</dd> <dd><strong>Cons</strong>: Relatively slow compilation time. Some verbose ceremony required still to declare arrays and anonymous objects. Surprisingly, I don‚Äôt remember any other issues that I had.</dd> </dl> <hr/> <h2 id="elm">Elm</h2> <dl> <dt>Used it in prod?</dt> <dd>‚úÖ Yes, barely</dd> <dt>Experience</dt> <dd>‚≠ê‚≠êüåëüåëüåë</dd> <dt>Enjoyment</dt> <dd>‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</dd> <dt>Comments</dt> <dd>I started using around 2020, built a few small SPAs with it, and quickly fell in love. It‚Äôs just illegal how good it is. As mostly a backend developer, I never expected I will be enjoying developing web applications so much. It simply has the best developer experience I ever witnessed. I learnt a lot from this language. If you‚Äôre curious about Elm and its potential use cases, I highly recommend checking out <a href="https://engineering.rakuten.today/post/elm-at-rakuten/">this</a> article.</dd> <dd><strong>Pros</strong>: There‚Äôs no concept of Exceptions in the language at all, errors are represented as data. The language is trying its best to make sure you‚Äôve exhaustively handled all the obviously possible errors and cases. Elm also doesn‚Äôt have <code class="language-plaintext highlighter-rouge">null</code> nor <code class="language-plaintext highlighter-rouge">undefined</code>, plus everything is strictly immutable. As a result it‚Äôs very unlikely you will ever meet crashes in a runtime. One good long-term effect for me from using Elm is that I started to take care of more of the ‚Äúunhappy paths‚Äù than I did before when I was working in other languages. State is concentrated and updated in one place and the language takes care of that. Functions are curried by default. Type system is sound and will infer the minimum sufficient type for any valid code if you don‚Äôt add any annotations, but it‚Äôs customary to write type annotation anyway. Error messages are best in class, compiler is really helpful. Compilation is very fast in comparison to the other compile-to-js languages, bundle sizes are relatively small (in comparison to React and Angular) Batteries included: core library is pretty amazing. Also, it‚Äôs not customary to have a big list of dependencies for an Elm project. It‚Äôs a very small language, I feel that I got productive with it in half a week from the absolute zero. I liked its task API more than JS Promises.</dd> <dd><strong>Cons</strong>: First main problem with Elm is it‚Äôs not popular. It‚Äôs <a href="https://2022.stateofjs.com/en-US/other-tools/#javascript_flavors">2nd most popular</a> JS-based language as of 2022, but it‚Äôs a huuuge drop from TypeScript. It‚Äôs not a problem of language, more of a problem of a language per se, it‚Äôs just that its future is quite unclear. The second problem I‚Äôve experienced with Elm is it gets you on the hook. Switching from Elm to JS/TS is an excruciating experience. I was desperately trying to find some language for a backend development that is distantly as good as Elm is and still haven‚Äôt found it. Some people don‚Äôt like the fact that Elm don‚Äôt have higher kinded types or ability to create custom infix operators. It‚Äôs true, but it makes it easier for newcomers to pick it up though. FFI with JS is deliberately cumbersome and tedious, as you need to pass the JS values through the ‚ÄúElm customs‚Äù that ensures the data has exactly the format you expect, which further decreasing the chances you will crash. Things you‚Äôre used like random number generation, logging, chaining effectful code can be tricky all of a sudden.</dd> </dl> <hr/> <h2 id="typescript">TypeScript</h2> <dl> <dt>Used it in prod?</dt> <dd>‚úÖ Yes</dd> <dt>Experience</dt> <dd>‚≠ê‚≠ê‚≠ê‚≠êüåë</dd> <dt>Enjoyment</dt> <dd>‚ù§Ô∏è‚ù§Ô∏èÔ∏è‚ù§Ô∏èüñ§üñ§</dd> <dt>Comments</dt> <dd>I started using it around mid 2021, mostly for a backend. I quickly realized it‚Äôs not really a language, but rather a family of languages depending on tsconfig you have, which I instantly set to the strictest level possible. When you search for type-related help on StackOverflow, chances other people‚Äôs config is different. Overall, it‚Äôs just a JS with types (not to downplay types significance), and thus TS inherits a lot of its virtues and vices.</dd> <dd><strong>Pros</strong>: I‚Äôve noticed it got easier for me to work on a codebases when it gets to a certain size, at least around 5k-10k lines of code. All because types information enables better hints in IDE and you get more relaxed as you at least get some level of certainty of what the data format will be at each point of execution. If you set <code class="language-plaintext highlighter-rouge">tsconfig</code> strict enough; if you will be disciplined not to use type casts and other dirty tricks pervasively; if you will parse &amp; validate all your input data from the outside world the moment you received it, then you might get a remotely good developer experience with TS. I also liked the fact that syntax for the curried function is very succinct in comparison to other typed imperative languages. I liked the tagless union types support, which is very handy at explicitly declaring all possible failure modes of your function execution results. Oftentimes you can make things <code class="language-plaintext highlighter-rouge">readonly</code> and <code class="language-plaintext highlighter-rouge">eslint</code> will check it for you, but it‚Äôs hard for 3rd party code. I absolutely love to deal with the structural types, not the nominal types. Literal types is another cool feature I like.</dd> <dd><strong>Cons</strong>: Compilation / transpilation / webpacking / running unit tests may be brutally slow. Type errors can be hard to read, at least until you get used to them and know where to look. Sometimes you get an impression that ‚ÄúType‚Äù in TypeScript really means ‚Äúto type more stuff for a false sense of security‚Äù, as underlying foundation is still an untyped JS: sooner rather than later you will find a type mismatch. There‚Äôs no escape from Chaos. You will inevitably find out that type definition for certain built-in core library functions is plain wrong, 3rd party packages won‚Äôt have type definitions, or they will be wrong, webpack will mess your code and your value will be <code class="language-plaintext highlighter-rouge">undefined</code> when it shouldn‚Äôt, and so on. Deliberately unsound type system will exhibit weird behaviors occasionally, with non-informative error message. Type assignability is not transitive sometimes: if any arbitrary type A is assignable to type B, and type B assignable to type C, there can be cases where assigning type A to type C will cause an error. Type inference is frustratingly wrong sometimes, it‚Äôs also rather bad with generics and too eager to make your type concrete <code class="language-plaintext highlighter-rouge">unknown</code>.</dd> </dl> <hr/> <h2 id="rust">Rust</h2> <dl> <dt>Used it in prod?</dt> <dd>‚ùå No</dd> <dt>Experience</dt> <dd>üåëüåëüåëüåëüåë</dd> <dt>Enjoyment</dt> <dd>‚ù§Ô∏è‚ù§Ô∏èÔ∏è‚ù§Ô∏è‚ù§Ô∏èüñ§</dd> <dt>Comments</dt> <dd>Rust is a great language with powerful low-level capabilities and a nice core library that includes excellent collection processing functions. Although I haven‚Äôt had a lot of experience with it, I‚Äôve enjoyed experimenting with Rust and fighting with its infamous borrow checker. I also wrote some proof-of-concept projects to demonstrate to my company how we could potentially replace certain parts of our TypeScript data processing with Rust, which according to my benchmarks could yield a 10x-100x performance boost in computation-intensive areas.</dd> </dl>]]></content><author><name></name></author><category term="languages"/><category term="programming"/><category term="languages"/><category term="programming"/><summary type="html"><![CDATA[List of the programming languages that I used so far]]></summary></entry></feed>